Вопрос 1. this в ООП  
Ответ: В объектно-ориентированном программировании ключевое слово `this` используется внутри методов объекта для ссылки на текущий объект, через который был вызван метод. Значение `this` определяется во время вызова метода и указывает на объект "перед точкой" при вызове `obj.method()`. Это позволяет методам обращаться к свойствам и другим методам того же объекта. В JavaScript, например, `this` внутри метода будет указывать на объект, у которого вызван метод. В строгом режиме `this` может быть `undefined`, если функция вызвана без контекста объекта. Стрелочные функции особенные — у них нет собственного `this`, и значение берется из внешнего контекста.
В Java ключевое слово this используется внутри методов класса для ссылки на текущий объект, с которым связан вызов метода. Это позволяет обращаться к полям и методам объекта, особенно когда имена параметров метода совпадают с именами полей класса. Основные случаи использования this в Java:
Доступ к полям объекта, когда имена параметров совпадают с именами полей:
public class Person {
    private String name;
    public Person(String name) {
        this.name = name;  // this.name — поле объекта, name — параметр конструктора
    }
}
Вызов другого конструктора из конструктора (конструкторская перегрузка):
public class Person {
    private String name;
    private int age;
    public Person() {
        this("Unknown", 0);  // вызов другого конструктора
    }
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
Передача текущего объекта как параметра:
public void register() {
    Database.save(this);  // передаем ссылку на текущий объект
}

Возврат текущего объекта из метода (для цепочек вызовов):
public Person setName(String name) {
    this.name = name;
    return this;
}


Вопрос 2. Абстрактные классы  
Ответ: Абстрактные классы — это базовые классы, которые нельзя инстанцировать напрямую, но можно наследовать. Они служат для объединения общей реализации нескольких похожих классов и могут содержать как реализованные методы и свойства, так и абстрактные (без реализации), которые должны быть реализованы в дочерних классах. Абстрактные классы помогают избежать дублирования кода и задают общий интерфейс для всех наследников. В объявлении абстрактного класса используется ключевое слово `abstract`. Все абстрактные члены (методы, свойства) должны быть реализованы в конкретных подклассах, если только подкласс не является абстрактным тоже.
Вопрос 3. Вычислительная сложность алгоритма. Асимптотическая оценка сложности: O(1), O(log N), O(N), O(N²), ... . Измерение времени работы программы.  

Ответ: Вычислительная сложность алгоритма характеризует, как растет время выполнения или объем памяти при увеличении размера входных данных n. Асимптотическая оценка описывается с помощью нотации Big O, которая показывает верхнюю границу роста:
- O(1) — константная сложность, время не зависит от размера данных.
- O(log N) — логарифмическая, например, бинарный поиск.
- O(N) — линейная, время пропорционально размеру данных.
- O(N²) — квадратичная, например, простые сортировки пузырьком.
При оценке игнорируются константы и меньшие по порядку члены. Для измерения времени работы программы в Python можно использовать модуль datetime или time, фиксируя время начала и окончания выполнения кода и вычисляя разницу.

Вопрос 4. Деревья. Бинарные деревья поиска.  
Ответ: Дерево — это структура данных, состоящая из узлов, связанных между собой. Бинарное дерево поиска (BST) — это дерево, где у каждого узла не более двух детей (левый и правый), и ключи в левом поддереве меньше или равны ключу в узле, а в правом — строго больше. Это позволяет эффективно выполнять операции поиска, вставки и удаления. В худшем случае время операций пропорционально высоте дерева. Для хранения узлов обычно используют структуры с полями для ключа и указателей на левого и правого потомка.

Вопрос 5. Иерархии классов. Наследование.  
Ответ: Наследование — это механизм ООП, позволяющий создавать новые классы на основе существующих, наследуя их свойства и методы. Это формирует иерархию классов, где дочерние классы расширяют или переопределяют функциональность родительских. Наследование уменьшает дублирование кода и упрощает поддержку. В языках программирования для наследования используется ключевое слово `extends` или аналог. Дочерний класс получает доступ к публичным и защищенным членам родительского класса.
Вопрос 6. Иерархия классов исключений и try catch finally  
Ответ: В Java исключения организованы в иерархию классов, где базовый класс — `Throwable`, от которого наследуются `Exception` и `Error`. Исключения могут быть проверяемыми (checked) и непроверяемыми (unchecked). Для обработки исключений используется конструкция `try-catch-finally`. Код в блоке `try` выполняется, если возникает исключение, управление передается в соответствующий `catch`, где происходит обработка. Блок `finally` выполняется всегда, независимо от исключений, и используется для освобождения ресурсов. Можно вкладывать `try-catch-finally` друг в друга для более тонкой обработки.

Вопрос 7. Интерфейсы и реализация интерфейсов.  
Ответ: Интерфейсы в Java — это абстрактные типы, которые определяют набор методов без реализации. Класс, реализующий интерфейс, обязан реализовать все его методы. Интерфейсы позволяют задавать контракты для классов и обеспечивают полиморфизм. Один класс может реализовывать несколько интерфейсов. Интерфейсы могут наследовать друг друга, расширяя набор методов. Также в интерфейсах могут быть статические методы и константы.

Вопрос 8. Классы. Инкапсуляция. Модификаторы доступа  
Ответ: Класс — это шаблон для создания объектов, объединяющий данные (поля) и методы. Инкапсуляция — принцип скрытия внутренней реализации объекта и предоставления доступа через методы. Для ограничения доступа используются модификаторы доступа:
- `public` — доступ везде.
- `private` — доступ только внутри класса.
- `protected` — доступ внутри класса и наследников.
- package-private (без модификатора) — доступ внутри пакета.
Модификаторы помогают контролировать видимость и защищают данные от неправильного использования.

Вопрос 9. Конструкторы классов  
Ответ: Конструктор — это специальный метод класса, вызываемый при создании объекта для инициализации его состояния. Конструкторы могут иметь параметры для задания начальных значений. В некоторых языках (например, Java) конструктор имеет имя класса и не возвращает значение. Если конструктор не определён явно, компилятор создает конструктор по умолчанию.

Вопрос 10. Массивы. Разница в использовании отсортированных и неотсортированных массивов.  
Ответ: Массив — структура данных, хранящая элементы одного типа в последовательных ячейках памяти. Отсортированные массивы упорядочены по возрастанию или убыванию, что позволяет применять быстрые алгоритмы поиска, например, бинарный поиск с логарифмической сложностью O(log N). Неотсортированные массивы не имеют порядка, поэтому поиск в них обычно линейный O(N). Отсортированные массивы удобны для частых операций поиска, а неотсортированные — для частых вставок и удалений без необходимости поддерживать порядок.

Вопрос 11. Полиморфизм. Перегрузка методов.  
Ответ: Полиморфизм — способность объектов разных классов реагировать на одинаковые сообщения (вызовы методов) по-разному. В ООП это достигается через наследование и переопределение методов. Перегрузка методов — это создание в одном классе нескольких методов с одинаковым именем, но разными параметрами (типами или количеством), что позволяет вызывать нужную версию метода в зависимости от аргументов.

Вопрос 12. Понятие «Двоичное дерево поиска». Реализация двоичного дерева поиска.  
Ответ: Двоичное дерево поиска — это бинарное дерево, где каждый узел содержит ключ, левый потомок содержит ключи не больше, правый — больше. Основные операции — поиск, вставка, удаление — выполняются за время, пропорциональное высоте дерева. Реализация узла может выглядеть так:
struct NodeTree {
    int data;
    NodeTree* left;
    NodeTree* right;
};

Вопрос 13. Реализация двусвязных списков.  
Ответ: Двусвязный список — структура данных, состоящая из элементов (узлов), каждый из которых содержит данные и два указателя: на следующий и предыдущий элементы. Это позволяет эффективно перемещаться в обоих направлениях. Пример структуры узла:
public class ListElemDouble {
	  String value;
	  ListElemDouble next = null;
	  ListElemDouble prev = null;
}

Вопрос 14. Реализация односвязных списков.  
Ответ: Односвязный список — структура данных, где каждый узел содержит данные и указатель только на следующий элемент, что позволяет перемещаться только в одном направлении. 
class ListElem {
	String value;
	ListElem next = null;

}

Вопрос 15. Библиотека Swing и графика в Java  
Ответ: Swing — это библиотека Java для создания графического интерфейса пользователя (GUI). Она предоставляет набор компонентов (кнопки, окна, меню и др.) и поддерживает события, рисование и работу с графикой. Swing построен поверх AWT и обеспечивает более гибкий и расширяемый интерфейс. Используется для разработки настольных приложений с графическим интерфейсом.

Вопрос 16. Работа с файлами в Java  
Ответ: В Java работа с файлами осуществляется через классы из пакета `java.io` и `java.nio`. Основные операции — чтение, запись, создание, удаление файлов. Для чтения и записи используют потоки ввода-вывода (`InputStream`, `OutputStream`, `Reader`, `Writer`). С помощью классов `File`, `Files` можно управлять файлами и каталогами. Также поддерживается работа с буферизацией и обработка исключений при работе с файлами.

Вопрос 17. Связанные списки.  
Ответ: Связанные списки — динамические структуры данных, состоящие из узлов, каждый из которых содержит данные и ссылки на другие узлы. Основные виды — односвязные (ссылка на следующий узел) и двусвязные (ссылки на следующий и предыдущий). Связанные списки удобны для вставки и удаления элементов без перераспределения памяти, но имеют линейное время доступа к элементам.

Вопрос 18. Сортировка массива. Примеры алгоритмов сортировки.  
Ответ: Сортировка массива — процесс упорядочивания элементов. Примеры алгоритмов:
- Пузырьковая сортировка (Bubble Sort) — простой, но медленный O(N²).
- Сортировка вставками (Insertion Sort) — эффективна для почти отсортированных данных O(N²).
- Быстрая сортировка (Quick Sort) — средняя сложность O(N log N).
- Сортировка слиянием (Merge Sort) — стабильная, O(N log N).
- Сортировка выбором (Selection Sort) — O(N²).
Выбор алгоритма зависит от размера и характера данных.
1. Пузырьковая сортировка (Bubble Sort)
Принцип: Последовательно сравниваются соседние элементы массива, и если они стоят в неправильном порядке, меняются местами. Этот процесс повторяется, пока весь массив не будет отсортирован.
Особенности: Очень простая реализация, но неэффективна для больших массивов.
Сложность: O(N²) — квадратичная.
Пример:

java
for (int i = 0; i < n - 1; i++) {
    for (int j = 0; j < n - i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
            // обмен элементов
            int temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
}
2. Сортировка вставками (Insertion Sort)
Принцип: Массив разбивается на отсортированную и неотсортированную части. Элементы из неотсортированной части по одному вставляются в правильное место отсортированной части.
Особенности: Хорошо работает на почти отсортированных массивах.
Сложность: O(N²) в худшем случае, O(N) в лучшем.
Пример:

java
for (int i = 1; i < n; i++) {
    int key = arr[i];
    int j = i - 1;
    while (j >= 0 && arr[j] > key) {
        arr[j + 1] = arr[j];
        j--;
    }
    arr[j + 1] = key;
}
3. Быстрая сортировка (Quick Sort)
Принцип: Выбирается опорный элемент (pivot), массив разбивается на две части: элементы меньше pivot и больше pivot. Затем рекурсивно сортируются обе части.
Особенности: Очень эффективна на практике, но в худшем случае может деградировать до O(N²).
Сложность: В среднем O(N log N).
Пример:

java
void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    return i + 1;
}
4. Сортировка слиянием (Merge Sort)
Принцип: Массив рекурсивно делится пополам до массивов из одного элемента, затем эти массивы сливаются в отсортированном порядке.
Особенности: Стабильная сортировка с гарантированной сложностью. Требует дополнительной памяти.
Сложность: O(N log N).
Пример:

java
void mergeSort(int[] arr, int left, int right) {
    if (left < right) {
        int mid = (left + right) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}

void merge(int[] arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    int[] L = new int[n1];
    int[] R = new int[n2];

    for (int i = 0; i < n1; i++) L[i] = arr[left + i];
    for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) arr[k++] = L[i++];
        else arr[k++] = R[j++];
    }
    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
}
5. Сортировка выбором (Selection Sort)
Принцип: На каждом шаге выбирается минимальный элемент из неотсортированной части массива и меняется местами с первым элементом этой части.
Особенности: Простая реализация, но неэффективна для больших массивов.
Сложность: O(N²).
Пример:

java
for (int i = 0; i < n - 1; i++) {
    int minIndex = i;
    for (int j = i + 1; j < n; j++) {
        if (arr[j] < arr[minIndex]) {
            minIndex = j;
        }
    }
    int temp = arr[minIndex];
    arr[minIndex] = arr[i];
    arr[i] = temp;
}

Вопрос 19. Статические элементы класса.  
Ответ: Статические элементы класса — поля и методы, связанные не с конкретным объектом, а с самим классом. Они существуют в единственном экземпляре для всего класса. Статические методы не могут обращаться к нестатическим полям напрямую. Используются для общих данных и функций, не зависящих от состояния объекта.

Вопрос 20. Хэш как структура данных  
Ответ: Хэш — структура данных, обеспечивающая быстрый доступ к элементам по ключу с помощью хеш-функции, которая преобразует ключ в индекс массива (хеш-таблицу). Основные операции (вставка, поиск, удаление) выполняются в среднем за O(1). Для разрешения коллизий применяют методы цепочек или открытой адресации. Хэш-структуры широко используются для реализации словарей и множеств.

